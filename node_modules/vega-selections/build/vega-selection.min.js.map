{"version":3,"file":"vega-selection.min.js","sources":["../src/constants.js","../src/selectionTest.js","../src/selectionResolve.js","../src/selectionVisitor.js"],"sourcesContent":["export const Intersect = 'intersect';\nexport const Union = 'union';\nexport const VlMulti = 'vlMulti';\nexport const VlPoint = 'vlPoint';\nexport const Or = 'or';\nexport const And = 'and';\n","import {Intersect} from './constants';\nimport {field, inrange, isArray, isDate, toNumber} from 'vega-util';\n\nvar TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    UNIT_INDEX = 'index:unit';\n\n// TODO: revisit date coercion?\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0, dval, f;\n\n  for (; i<n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if(isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\nexport function selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry, miss, count, unit, b;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit=entry.unit] || 0;\n\n      // if we've already matched this unit, skip.\n      if (count === -1) continue;\n\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count;\n\n      // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry);\n\n      // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n      if (intersect ^ b) return b;\n    }\n  }\n\n  // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n  return n && intersect;\n}","import {And, Or, Union, VlMulti, VlPoint} from './constants';\nimport {array, toNumber} from 'vega-util';\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\nexport function selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    resolved = {}, multiRes = {}, types = {},\n    entry, fields, values, unit, field, res, resUnit, type, union,\n    n = entries.length, i = 0, j, m;\n\n  // First union all entries within the same unit.\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    for (j = 0, m = fields.length; j < m; ++j) {\n      field = fields[j];\n      res = resolved[field.field] || (resolved[field.field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      types[field.field] = type = field.type.charAt(0);\n      union = ops[type + '_union'];\n      res[unit] = union(resUnit, array(values[j]));\n    }\n\n    // If the same multi-selection is repeated over views and projected over\n    // an encoding, it may operate over different fields making it especially\n    // tricky to reliably resolve it. At best, we can de-dupe identical entries\n    // but doing so may be more computationally expensive than it is worth.\n    // Instead, for now, we simply transform our store representation into\n    // a more human-friendly one.\n    if (isMulti) {\n      resUnit = multiRes[unit] || (multiRes[unit] = []);\n      resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n    }\n  }\n\n  // Then resolve fields across units as per the op.\n  op = op || Union;\n  Object.keys(resolved).forEach(field => {\n    resolved[field] = Object.keys(resolved[field])\n      .map(unit => resolved[field][unit])\n      .reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));\n  });\n\n  entries = Object.keys(multiRes);\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union\n      ? {[Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])}\n      : {[And]: entries.map(k => ({[Or]: multiRes[k]}))};\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  E_union: function(base, value) {\n    if (!base.length) return value;\n\n    var i = 0, n = value.length;\n    for (; i<n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n    return base;\n  },\n\n  E_intersect: function(base, value) {\n    return !base.length ? value :\n      base.filter(v => value.indexOf(v) >= 0);\n  },\n\n  R_union: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n\n  R_intersect: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n    return base;\n  }\n};\n","import {Intersect} from './constants';\nimport {Literal} from 'vega-expression';\nimport {error, hasOwnProperty, peek} from 'vega-util';\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\n\nexport function selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}"],"names":["Intersect","Union","UNIT_INDEX","testPoint","datum","entry","dval","f","fields","values","n","length","i","getter","field","isDate","toNumber","map","type","isArray","indexOf","inrange","ops","E_union","base","value","push","E_intersect","filter","v","R_union","lo","hi","R_intersect","name","op","isMulti","vl5","unit","res","resUnit","union","j","m","data","this","context","entries","resolved","multiRes","types","charAt","array","reduce","obj","curr","Object","keys","forEach","acc","undefined","k","miss","count","b","unitIdx","intersect","size","get","args","scope","params","Literal","error","indexName","IndexPrefix","dataName","peek","hasOwnProperty","getData","indataRef","tuplesRef"],"mappings":"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"}